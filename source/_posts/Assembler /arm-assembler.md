---
title: assembler 
date: 2024年 03月 18日 星期一 22:59:32 CST
tags: [assembler ]
categories: assembler 
---

### Cortex-A 的内核寄存器组
![register](/images/Assembler/arm-assembler/register.png)

### 赋值指令 MOV、LDR

#### MOV
``` bash
MOV 目标寄存器 , 立即数
MOV R0,#1 			;为寄存器R0赋值，值为1
```

#### LDR
``` bash
LDR 目标寄存器 , = 赋值数
LDR R0,=0xAB00CD 	;为寄存器R0赋值，值为0xAB00CD
```

### 算数指令 ADD、SUB、MUL

#### ADD加法
``` bash
ADD 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
ADD R0,R0,R1 		;*R0 = *R0 + *R1
ADD R0,R0,#10 		;*R0 = *R0 + 10
```

#### SUB减法
``` bash
SUB 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
SUB R0,R0,R1 		;*R0 = *R0 - R1
SUB R0,R0,#10 		;*R0 = *R0 - 10
```

#### MUL乘法
``` bash
MUL 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
MUL R0,R0,R1 		;*R0 = *R0 * R1
MUL R0,R0,#10 		;*R0 = *R0 * 10
```

### 移位指令 LSL、LSR

#### LSL左移位
``` bash
MOV 目标寄存器 , 寄存器1 , LSL 立即数
MOV R0,R1,LSL #4 		;*R0 = *R1 << 4
```

#### LSR右移位
``` bash
MOV 目标寄存器 , 寄存器1 , LSR 立即数
MOV R0,R1,LSR #4 		;*R0 = *R1 >> 4
```

### 逻辑位指令 AND、ORR、MVN、EOR

#### AND与
``` bash
AND 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
AND R0,R0,R1			;*R0 = *R0 & *R1
AND R0,R0,#0X0F			;*R0 = *R0 & 0X0F
```

#### ORR或
``` bash
ORR 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
ORR R0,R0,R1			;*R0 = *R0 | *R1
ORR R0,R0,#0X0F			;*R0 = *R0 | 0X0F
```

#### MVN非
``` bash
MVN 目标寄存器 , 寄存器2（也可以是立即数）
MVN R0,R1				;*R0 = ~*R1
MVN R0,#0X0F			;*R0 = ~0X0F
```

#### EOR异或
``` bash
EOR 目标寄存器 , 寄存器1 , 寄存器2（也可以是立即数）
EOR R0,R0,R1			;*R0 = *R0 ^ *R1
EOR R0,R0,#0X0F			;*R0 = *R0 ^ 0X0F
```

### 跳转指令 B、BL

#### B直接跳转
``` bash
B 跳转地址（可以是标签，因为标签就是地址）
---------------------------------------------------
	MOV R0,#100			;*R0 = 100
	B set_R1			;goto set_R1 （该操作也可以使用 LDR PC,=set_R1 理论是一样的）
	ADD R2,R0,R1		;*R2 = *R0 + *R1 这里将不会执行，因为跳转到set_R1无法再回到当前位置

set_R1:
	MOV R1,#200
---------------------------------------------------  
```

#### BL暂存当前位置后直接跳转
``` bash
B L 跳转地址（可以是标签，因为标签就是地址）
---------------------------------------------------
   MOV R0,#100			;*R0 = 100
   BL set_R1			;goto set_R1 （该操作也可以使用: MOV LR,PC   SUB LR,LR,#4   LDR PC,=set_R1 理论是一样的）
   ADD R2,R0,R1		    ;*R2 = *R0 + *R1 这里将不会执行，因为跳转到set_R1无法再回到当前位置
   
set_R1:
   MOV R1,#200
   MOV PC,LR
---------------------------------------------------  
```

### 比较指令 CMP：EN、EQ、GT、LT、GE、LE
``` bash
CMP 比较寄存器1，比较寄存器2（也可以是立即数）
EN -- 等于
EQ -- 等于
GT -- 大于
LT -- 小于
GE -- 大于等于
LE -- 小于等于
```

``` bash
例如：
允许赋值指令
    CMP R0,R1
    MOVEN ,R2,R1

    if(*R0 == *R1) *R2 = *R1;

允许算数指令
    CMP R0,R1
    ADDEN ,R2,R0,R1

    if(*R0 == *R1) *R2 = *R0 + *R1;

允许逻辑位指令
    CMP R0,R1
    EOREN R2,R0,R1

    if(*R0 == *R1) *R2 = *R0 & *R1;

允许跳转指令
    CMP R0,R1
    BLEN  fun

    CMP R0,R1
    BEN  fun

    if(*R0 == *R1) goto fun;
```
### 单个内存读写指令 LDR、STR

#### LDR 读取内存的地址
``` bash
普通： LDR 目标寄存器 ，[读取地址]
基地址偏移： LDR 目标寄存器 ，[读取地址，纯偏移]
基地址偏移+改变 ：LDR 目标寄存器 ，[读取地址，偏移并改变]！
普通+改变 ：LDR 目标寄存器 ，[读取地址]， 偏移并改变

LDR R0,[R1]             R0 = *R1
LDR R0,[R1, #4]         R0 = *(R1 + 4)
LDR R0,[R1, #4]!        R0 = *(R1 + 4), R1 = R1 + 4
LDR R0,[R1],#4          R0 = *R1, R1 = R1 + 4
```

#### LDP 加载指令
``` bash
LDP指令从目标内存地址中加载数据，并将其存储到和或和寄存器中。加载的数据可以是32位或64位，具体取决于使用的寄存器。
LDP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
LDP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

<Wt1>和<Wt2>表示要加载的两个32位通用寄存器，
<Xt1>和<Xt2>表示要加载的两个64位通用寄存器。
[<Xn|SP>]表示要加载的内存地址，是一个可选的偏移量。

例如：
    LDP X0, X1, [X2]      ; 从[X2]地址中加载值到X0和X1寄存器
    LDP W3, W4, [SP, #16] ; 从[SP+16]地址中加载值到W3和W4寄存器
```

#### STR 写入内存的地址
``` bash
普通： STR 目标寄存器 ，[读取地址]
基地址偏移： STR 目标寄存器 ，[读取地址，纯偏移]
基地址偏移+改变 ：STR 目标寄存器 ，[读取地址，偏移并改变]！
普通+改变 ：STR 目标寄存器 ，[读取地址]， 偏移并改变

STR R0,[R1]             *R1 = R0
STR R0,[R1, #4]         *(R1 + 4) = R0
STR R0,[R1, #4]!        *(R1 + 4) = R0, R1 = R1 + 4
STR R0,[R1],#4          *R1 = R0, R1 = R1 + 4
```

#### STP 存储指令
``` bash
STP指令将 <Wt1> 和 <Wt2> 或 <Xt1> 和 <Xt2> 的值存储到目标内存地址中，并且递增目标内存地址以便下一次存储。存储的数据可以是32位或64位，具体取决于使用的寄存器。
STP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]
STP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

<Wt1>和<Wt2>表示两个要存储的32位通用寄存器，
<Xt1>和<Xt2>表示两个要存储的64位通用寄存器。
[<Xn|SP>]表示存储的目标内存地址，是一个可选的偏移量。

例如：
    STP X0, X1, [X2]      ; 将X0和X1的值存储到[X2]地址中
    STP W3, W4, [SP, #16] ; 将W3和W4的值存储到[SP+16]地址中
```

### 多个内存读写指令 STM、LDM

#### STM
``` bash
模式
IA 先读写，后增加地址
IB 先增加地址，后读写
DA 先读写，后减少地址
DB 先减少地址，后读写
指令+模式 基地址值(必须是寄存器)，{写入值}		;基地址(寄存器) 的地址不会发生改变
指令+模式 基地址值(必须是寄存器)!,{写入值}		;基地址(寄存器) 的地址会发生改变
```

#### LDM
``` bash
LDM 读取基地址内存中的数据，存放到其它地址中
```

### MRS 状态寄存器到通用寄存器的传送指令
``` bash
MRS指令的格式为：
MRS{条件}     通用寄存器，程序状态寄存器（CPSR/SPSR）
MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情冴： 
    Ⅰ.当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。
    Ⅱ.当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。
指令示例：
MRS R0，CPSR                          ；传送CPSR的内容到R0
MRS R0，SPSR                          ；传送SPSR的内容到R0
```

### MSR 通用寄存器到状态寄存器的传送指令
``` bash
MSR指令的格式为：
MSR{条件}     程序状态寄存器（CPSR/SPSR）_<域>，操作数
MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器戒立即数。<域>用亍设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：
位[31：24]为条件标志位域，用f表示；
位[23：16]为状态位域，用s表示；
位[15：8]为扩展位域，用x表示；
位[7：0]为控制位域，用c表示；

该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。
指令示例：
MSR CPSR，R0         ；传送R0的内容到CPSR
MSR SPSR，R0         ；传送R0的内容到SPSR
MSR CPSR_c，R0       ；传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域
```